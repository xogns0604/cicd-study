pipeline {
   agent any
   
   tools {
       jdk 'jdk17'
   }
   
   environment {
       DOCKER_IMAGE = 'cicd-test-project'
       DOCKER_TAG = "${BUILD_NUMBER}"
       DOCKER_SERVER = '10.200.2.99'  
       DOCKER_SERVER_USER = 'clovir'    
   }
   
  triggers {
       githubPush()
   }
   
   stages {
       stage('Check Branch') {
          steps {
              script {
                  def targetBranch = sh(script: 'git name-rev --name-only HEAD', returnStdout: true).trim()
                  echo "Current branch: ${targetBranch}"
                  if (!(targetBranch ==~ /.*main$/)) {  // main으로 끝나는 브랜치명 체크
                      error("CD pipeline should only run on main branch. Current branch: ${targetBranch}")
                  }
              }
          }
      }
       
       stage('Checkout') {
           steps {
               checkout scm
           }
       }
       
       stage('Build') {
           steps {
               sh '''
                   chmod +x ./gradlew
                   ./gradlew clean build -x test
               '''
           }
       }
       
       stage('Docker Build') {
          steps {
              sshagent(['docker-server-ssh']) {
                  sh """
                      # 배포 디렉토리 생성
                      ssh -o StrictHostKeyChecking=no ${DOCKER_SERVER_USER}@${DOCKER_SERVER} 'mkdir -p ~/deploy'
                      
                      # 빌드된 JAR 파일만 전송 (Dockerfile은 이미 서버에 있다고 가정)
                      scp -o StrictHostKeyChecking=no build/libs/*.jar ${DOCKER_SERVER_USER}@${DOCKER_SERVER}:~/deploy/
                      
                      # 원격 서버에서 Docker 빌드 실행
                      ssh -o StrictHostKeyChecking=no ${DOCKER_SERVER_USER}@${DOCKER_SERVER} '\
                          cd ~/deploy && \
                          echo "FROM openjdk:17-jdk-slim\nCOPY *.jar app.jar\nENTRYPOINT [\\"java\\",\\"-jar\\",\\"/app.jar\\"]" > Dockerfile && \
                          docker build -t ${DOCKER_IMAGE}:${DOCKER_TAG} .'
                  """
              }
          }
      }
       
       stage('Docker Deploy') {
          steps {
              sshagent(['docker-server-ssh']) {
                  sh """
                      # 원격 서버에서 기존 컨테이너 중지 및 제거
                      ssh -o StrictHostKeyChecking=no ${DOCKER_SERVER_USER}@${DOCKER_SERVER} '\
                          docker ps -f name=cicd-test-project -q | xargs --no-run-if-empty docker stop && \
                          docker ps -a -f name=cicd-test-project -q | xargs --no-run-if-empty docker rm'
                      
                      # 이미지는 이미 원격 서버에 빌드되어 있으므로 save/load 필요 없음
                      
                      # 원격 서버에서 새 버전 배포
                      ssh -o StrictHostKeyChecking=no ${DOCKER_SERVER_USER}@${DOCKER_SERVER} '\
                          docker run -d \
                              --name cicd-test-project \
                              -p 8080:8080 \
                              ${DOCKER_IMAGE}:${DOCKER_TAG}'
                  """
              }
          }
      }
       
       stage('Health Check') {
           steps {
               sh """
                   sleep 30  # 애플리케이션 시작 대기
                   curl -f http://${DOCKER_SERVER}:8080/actuator/health || exit 1
               """
           }
       }
   }
   
   post {
       success {
           echo 'CD Pipeline succeeded!'
       }
       failure {
           echo 'CD Pipeline failed!'
           sshagent(['docker-server-ssh']) {
               sh """
                   ssh -o StrictHostKeyChecking=no ${DOCKER_SERVER_USER}@${DOCKER_SERVER} '\
                       docker stop cicd-test-project && \
                       docker rm cicd-test-project && \
                       docker run -d \
                           --name cicd-test-project \
                           -p 8080:8080 \
                           ${DOCKER_IMAGE}:${BUILD_NUMBER.toInteger() - 1}'
               """
           }
       }
       always {
           sshagent(['docker-server-ssh']) {
               sh """
                   ssh -o StrictHostKeyChecking=no ${DOCKER_SERVER_USER}@${DOCKER_SERVER} '\
                       docker images ${DOCKER_IMAGE} --format "{{.ID}}" | \
                       sort -r | \
                       tail -n +4 | \
                       xargs --no-run-if-empty docker rmi'
               """
           }
       }
   }
}
